# -*- coding: utf-8 -*-
"""Copy of 1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z7db4FDGa6oeN7DE0Kn493ehdBudShqB
"""

#pip install openai==0.28

#!pip install ibm_watsonx_ai

"""# 1-Load the Knowledge Base"""

import pandas as pd
df=pd.read_json('arabic_poetry_with_emotions.json')
df.head()

pip install transformers datasets faiss-cpu torch

pip install rank_bm25 faiss-cpu sentence-transformers

"""# 2-Integrate Both Retrieval Methods

**a-Implement BM25 for Sparse Retrieval**
"""

from rank_bm25 import BM25Okapi
import pandas as pd


# Example columns in the dataset (adjust based on your data):
# Columns: ['العصر', 'الشاعر', 'الديوان', 'القافية', 'البحر', 'الشطر الايسر', 'الشطر الايمن', 'البيت', 'emotion']

# Combine relevant fields for the BM25 search
df['combined_text'] = df[['الشاعر', 'العصر', 'القافية', 'البحر']].apply(lambda row: ' '.join(row.values.astype(str)), axis=1)

# Tokenize the corpus (poems with poet, era, rhyme, and meter)
tokenized_corpus = [doc.split(" ") for doc in df['combined_text'].values]

# Initialize BM25 model
bm25 = BM25Okapi(tokenized_corpus)

# Example query
query = "الفرزدق الأموي الطويل ل"

# Tokenize the query
tokenized_query = query.split(" ")

# Get BM25 rankings
bm25_scores = bm25.get_scores(tokenized_query)

# Get top N results (adjust N as per your need)
top_n = 10
top_bm25_results = df.loc[bm25_scores.argsort()[::-1]].head(top_n)

# Separate each attribute into individual lists
poets = top_bm25_results['الشاعر'].tolist()
eras = top_bm25_results['العصر'].tolist()
rhymes = top_bm25_results['القافية'].tolist()
meters = top_bm25_results['البحر'].tolist()
diwans = top_bm25_results['الديوان'].tolist()
left_hemistichs = top_bm25_results['الشطر الايسر'].tolist()
right_hemistichs = top_bm25_results['الشطر الايمن'].tolist()
lines = top_bm25_results['البيت'].tolist()
emotions = top_bm25_results['emotion'].tolist()

# If you need to store them in variables, you can do so:
top_poets = poets       # Top poets from BM25
top_eras = eras         # Top eras from BM25
top_rhymes = rhymes     # Top rhymes from BM25
top_meters = meters     # Top meters from BM25
top_diwans = diwans     # Top diwans from BM25
top_left_hemistichs = left_hemistichs   # Top left hemistichs from BM25
top_right_hemistichs = right_hemistichs  # Top right hemistichs from BM25
top_lines = lines       # Top lines from BM25
top_emotions = emotions # Top emotions from BM25

# Displaying the result
print("Poets:", top_poets)
print("Eras:", top_eras)
print("Rhymes:", top_rhymes)
print("Meters:", top_meters)
print("Diwans:", top_diwans)
print("Left Hemistichs:", top_left_hemistichs)
print("Right Hemistichs:", top_right_hemistichs)
print("Lines:", top_lines)
print("Emotions:", top_emotions)

"""**b-Implement FAISS for Dense Retrieval (Semantic Matching)**"""

from sentence_transformers import SentenceTransformer
import faiss
import numpy as np
import pandas as pd



poetry_data = df.to_dict('records')  # Convert to list of dictionaries

# Initialize the Sentence-BERT model
model = SentenceTransformer('sentence-transformers/bert-base-nli-mean-tokens')

# Encode the poems into embeddings
poem_texts = [poem['البيت'] for poem in poetry_data]  # Extract poem lines
poem_embeddings = model.encode(poem_texts, convert_to_tensor=False)  # Encode into embeddings

# Convert the list of embeddings to a NumPy array
poem_embeddings = np.array(poem_embeddings)

# Initialize FAISS index for fast retrieval
dimension = poem_embeddings.shape[1]
index = faiss.IndexFlatL2(dimension)  # Using L2 distance
index.add(poem_embeddings)  # Add embeddings to the FAISS index

print("FAISS index built with poem embeddings!")

"""# 5-User inputs"""

import ipywidgets as widgets
from IPython.display import display

# قوائم منسدلة للمستخدم
poet_names = [
    'الطرماح بن حكيم الطائي', 'الراعي النُمَيري', 'عروة بن أذينة', 'سبيعة بنت الأحب',
    'أبو دؤاد الإيادي', 'عَبدُ مالِك بن النُّعْمان'
]

meters = [
    'الكامل', 'الطويل', 'المتقارب', 'البسيط', 'الوافر', 'المديد', 'الرمل',
    'السريع', 'الرجز', 'الخفيف', 'المنسرح', 'المجتث', 'موشح', 'الهزج',
    'شعر التفعيلة', 'المتدارك', 'عامي', 'شعر حر', 'السلسلة', 'المواليا', 'الدوبيت'
]

emotions = ['Pride', 'Praise', 'Sadness', 'Satire', 'Love']

# إنشاء القوائم المنسدلة
poet_dropdown = widgets.Dropdown(
    options=poet_names,
    description='Poet:'
)

meter_dropdown = widgets.Dropdown(
    options=meters,
    description='Meter:'
)

emotion_dropdown = widgets.Dropdown(
    options=emotions,
    description='Emotion:'
)

context_text = widgets.Text(
    description='Context:'
)

# دالة لجمع المدخلات عند الضغط على الزر
def get_user_input(b):
    user_input = {
        "poet_name": poet_dropdown.value,
        "meter": meter_dropdown.value,
        "emotion": emotion_dropdown.value,
        "context": context_text.value
    }
    print(user_input)

# زر للتأكيد
submit_button = widgets.Button(description="Submit")
submit_button.on_click(get_user_input)

# عرض الواجهة
display(poet_dropdown, meter_dropdown, emotion_dropdown, context_text, submit_button)

"""# 3-Teacher Model

**a-Initialize OpenAI API**
"""

import openai

# Set your API key
openai.api_key = "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"

# Set your organization ID
openai.organization = "org-7JEF5EfXn6q1t2v3nPWPfaZU"  # Your organization ID from OpenAI

# Make an API call to the chat model (gpt-3.5-turbo)
response = openai.ChatCompletion.create(
    model="gpt-4o-mini",            # Use the appropriate chat model (e.g., gpt-4 if available)
    messages=[                        # Messages parameter is required for chat models
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": "What is the capital of France?"}
    ],
    user="proj_zyjAv1AkJLtrhoLGx5ibCKwP"            # Add project information for tracking
)

# Print the model's response
print(response['choices'][0]['message']['content'])

"""# 4-Student Model

**b-Initialize ALLAM API**
"""

import os
import getpass
from ibm_watsonx_ai.foundation_models import Model

# Function to get credentials securely
def get_credentials():
    return {
        "url": "https://eu-de.ml.cloud.ibm.com",  # Verify that this URL is correct for your service region
        "apikey": getpass.getpass("Enter your API key: ")  # Securely input API key
    }

# Fetch credentials
credentials = get_credentials()

# Define the model ID, ensuring it is correct and properly deployed on IBM Watsonx AI
model_id = "sdaia/allam-1-13b-instruct"  # Make sure this model ID matches the deployed model

# Define the parameters for model inference
parameters = {
    "decoding_method": "greedy",
    "max_new_tokens": 900,
    "repetition_penalty": 1.0
}

# Set up project and space IDs; ensure these IDs are correctly retrieved or set
project_id = "65870abf-b0eb-4dce-9b63-eeed50e3a3d0"  # Replace with your actual project ID
space_id = os.getenv("SPACE_ID")  # Make sure SPACE_ID is set in your environment variables

# Initialize the model using the IBM Watsonx AI SDK
try:
    model = Model(
        model_id=model_id,
        params=parameters,
        credentials=credentials,
        project_id=project_id,
        space_id=space_id
    )
    print("Model initialized successfully!")
except Exception as e:
    print(f"Error initializing the model: {e}")

"""# 5-TEACHING and LEARNING

**a-Teacher Model Provides Few-Shot Examples on metaphore meaning and emotion, Student Model Generates a Poem**
"""

import openai
from sentence_transformers import SentenceTransformer
import numpy as np
from ibm_watsonx_ai.foundation_models import Model  # Import Watsonx AI SDK Model


openai.api_key = "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"
# Initialize the pre-trained model for embedding
embedding_model = SentenceTransformer('bert-base-nli-mean-tokens')

# FAISS-based poem retrieval function (assuming FAISS index and poem texts are pre-loaded)
def search_poems_faiss(query, num_results=5):
    try:
        query_embedding = embedding_model.encode([query], convert_to_tensor=False)
        distances, indices = index.search(np.array(query_embedding), num_results)
        return [poem_texts[i] for i in indices[0]]
    except NameError:
        print("FAISS index or poem texts are not loaded.")
        return ["Poem example 1", "Poem example 2", "Poem example 3"]  # Placeholder poems

# Step 1: Teacher model retrieves detailed metaphors and context based on emotion
def retrieve_emotion_context(emotion):
    messages = [
        {
            "role": "system",
            "content": """أنت خبير في الأدب والشعر العربي. هدفك هو تقديم استعارات وصور شعرية غنية ومؤثرة تصف الشعور المحدد. ركز على كيفية استخدام الشعراء للصور البلاغية (مثل الاستعارات والتشبيهات) للتعبير عن هذا الشعور. قم بتقديم أمثلة على صور شعرية تعكس هذا الشعور بشكل قوي."""
        },
        {
            "role": "user",
            "content": f"قدم لي استعارات وتعبيرات تعبر عن شعور {emotion}. الرجاء التركيز على توضيح هذا الشعور بمثالين أو ثلاثة."
        }
    ]

    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=messages,
        max_tokens=300,
        temperature=0.7
    )

    emotion_context = response['choices'][0]['message']['content'].strip()
    return emotion_context

# Step 2: Student model (Watson) generates a poem based on the retrieved context from the teacher and RAG
def generate_student_poem_with_watson(emotion_context, emotion, watson_model):
    query = f"Emotion: {emotion}"
    retrieved_poems = search_poems_faiss(query, num_results=5)
    extra_examples = "\n\n".join(retrieved_poems)

    print(f"الأمثلة المسترجعة من FAISS حول الشعور {emotion}:\n{extra_examples}\n")

    formatted_question = f"""<s> [INST] بناءً على السياق التالي الذي قدمه المعلم:
    "{emotion_context}"

    وهنا بعض الأمثلة المسترجعة من القصائد المشابهة:
    "{extra_examples}"

    اكتب قصيدة تعكس هذا الشعور بطريقة مبتكرة، مع استخدام استعارات تعبر عن هذا الشعور بعمق ووضوح. [/INST]"""

    prompt_input = ""
    prompt = f"{prompt_input}{formatted_question}"

    generated_response = watson_model.generate_text(prompt=prompt, guardrails=False)
    return generated_response

# Step 3: Teacher model evaluates the poem generated by the student and provides feedback for improvements
def evaluate_and_provide_feedback(poem, emotion):
    messages = [
        {
            "role": "system",
            "content": """أنت خبير في الأدب والشعر العربي. مهمتك هي تقييم قصيدة مولدة من طالب بناءً على سياق محدد. عليك تقديم ملاحظات تفصيلية حول مدى تعبير القصيدة عن الشعور المراد (مثل الفرح، الحزن) وتقديم اقتراحات لتحسين الاستعارات والصور البلاغية."""
        },
        {
            "role": "user",
            "content": f"القصيدة التالية كتبت لتعكس شعور {emotion}. قدم ملاحظات وتحسينات:\n\n{poem}"
        }
    ]

    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=messages,
        max_tokens=300,
        temperature=0.7
    )

    feedback = response['choices'][0]['message']['content'].strip()
    return feedback

# Step 4: Student model revises the poem based on teacher feedback
def revise_poem_with_watson(feedback, poem, watson_model):
    formatted_question = f"""<s> [INST] المعلم قدم الملاحظات التالية حول القصيدة:
    "{feedback}"

    القصيدة الأصلية:
    "{poem}"

    قم بتحسين القصيدة بناءً على ملاحظات المعلم وأعد صياغتها بطريقة تعبر عن الشعور بشكل أقوى. [/INST]"""

    prompt_input = ""
    prompt = f"{prompt_input}{formatted_question}"

    revised_poem = watson_model.generate_text(prompt=prompt, guardrails=False)
    return revised_poem

# Main function to run the process
def main():
    credentials = {
        "url": "https://eu-de.ml.cloud.ibm.com",
        "apikey": "bkIJnxA7mDVQPkbqGnjbeWQZnNjqXIoM9nmP5f7tQ_jU"
    }

    model_id = "sdaia/allam-1-13b-instruct"
    parameters = {
        "decoding_method": "greedy",
        "max_new_tokens": 500,
        "repetition_penalty": 1.0
    }

    project_id = "65870abf-b0eb-4dce-9b63-eeed50e3a3d0"
    space_id = os.getenv("SPACE_ID")

    watson_model = Model(
        model_id=model_id,
        params=parameters,
        credentials=credentials,
        project_id=project_id,
        space_id=space_id
    )

    emotion = "فرح"

    # Step 1: Teacher retrieves metaphors and context based on emotion
    emotion_context = retrieve_emotion_context(emotion)
    print(f"السياق المسترجع من المعلم حول الشعور {emotion}:\n{emotion_context}\n")

    # Step 2: Student generates initial poem
    initial_poem = generate_student_poem_with_watson(emotion_context, emotion, watson_model)
    print(f"القصيدة المولدة من الطالب:\n{initial_poem}\n")

    # Step 3: Teacher evaluates the poem and provides feedback
    teacher_feedback = evaluate_and_provide_feedback(initial_poem, emotion)
    print(f"ملاحظات المعلم:\n{teacher_feedback}\n")

    # Step 4: Student revises the poem based on teacher's feedback
    revised_poem = revise_poem_with_watson(teacher_feedback, initial_poem, watson_model)
    print(f"القصيدة المنقحة:\n{revised_poem}\n")

    return revised_poem

# Run the main process
if __name__ == "__main__":
    final_poem = main()

"""**b-Teacher Model Provides Poet’s Life Context, Student Model Rewrites the Poem**

**c-Teacher Model Provides Rhythm (Meter), Student Model Fixes the Poem Based on Meter**
"""

import openai
from sentence_transformers import SentenceTransformer
import numpy as np

def search_poems_faiss(query, num_results=5):
    # Encode the query into an embedding
    query_embedding = model.encode([query], convert_to_tensor=False)

    # Search for top N closest embeddings using FAISS
    distances, indices = index.search(np.array(query_embedding), num_results)

    # Return the top N poems based on FAISS ranking
    return [poem_texts[i] for i in indices[0]]

# Step 3: Teacher model analyzes and corrects the poem's meter and rhyme scheme
def correct_poem_meter_and_rhyme(student_poem, meter, rhyme):
    messages = [
        {
            "role": "system",
            "content": f"""أنت خبير في العروض والشعر العربي. هدفك هو تحليل القصيدة التالية وتقديم التصحيحات اللازمة وفقًا للوزن والبحر الشعري ({meter}) ونظام القافية ({rhyme}). قدم الصيغة العروضية الصحيحة لهذا البحر، واقترح القافية الصحيحة التي تتناسب مع الأبيات.

البحر الطويل يتكون من التفعيلات التالية: فعولن مفاعيلن فعولن مفاعيلن.
التزم بهذه التفعيلات في كل شطر من القصيدة، وقم بتعديل الأبيات بحيث تتماشى مع هذه الصيغة العروضية.

بالنسبة للقافية ({rhyme})، تأكد من أن نهاية كل بيت تتبع هذا النظام واقترح قافية مناسبة إذا لم تكن موجودة.
            """
        },
        {
            "role": "user",
            "content": f"""
            هذه القصيدة التي كتبها الطالب:
            "{student_poem}"

            الرجاء تصحيح الوزن العروضي والقافية لهذه القصيدة وفقًا للبحر {meter} والقافية {rhyme}.
            """
        }
    ]

    response = openai.ChatCompletion.create(
        model="gpt-4",  # Using GPT-4 for teacher model
        messages=messages,
        max_tokens=300,  # Adjust for detailed feedback
        temperature=0.7
    )

    # Extract the feedback from the teacher model
    meter_rhyme_correction = response['choices'][0]['message']['content'].strip()
    return meter_rhyme_correction

# Student model rewrites the poem based on feedback from the teacher and examples from RAG
def rewrite_poem_with_meter_and_rhyme_feedback(student_poem, meter_rhyme_correction, meter, rhyme):
    # Retrieve top 5 poems with the correct meter and rhyme using FAISS
    query = f"Meter: {meter}, Rhyme: {rhyme}"
    retrieved_meter_rhyme_poems = search_poems_faiss(query, num_results=5)

    # Prepare the top 5 retrieved poems with the correct meter and rhyme
    meter_rhyme_examples = "\n\n".join(retrieved_meter_rhyme_poems)

    # Print the retrieved examples of poems with the correct meter and rhyme
    print(f"الأمثلة المسترجعة من FAISS حول البحر {meter} والقافية {rhyme}:\n{meter_rhyme_examples}\n")

    # Student model prompt with the original poem, feedback from the teacher, and meter and rhyme examples
    messages = [
        {
            "role": "system",
            "content": """ بناءً على التصحيح المقدم من المعلم حول الوزن العروضي ونظام القافية، هدفك هو إعادة كتابة القصيدة بحيث تتوافق مع الوزن المناسب والقافية الصحيحة. استخدم الاستعارات والصور الشعرية السابقة، وركز على كيفية دمجها مع الوزن والقافية بشكل سلس.

تذكر أن البحر الطويل يتكون من تفعيل "فعولن مفاعيلن فعولن مفاعيلن"، والقافية التي اخترتها هي "{rhyme}". تأكد من أن نهاية كل بيت تتبع هذا النظام بدقة. استعن بالأمثلة المسترجعة من القصائد لتوضيح كيفية تطبيق الوزن العروضي والقافية.
            """
        },
        {
            "role": "user",
            "content": f"""
            هذه هي القصيدة الأصلية التي كتبتها:
            "{student_poem}"

            وهنا التصحيحات التي قدمها المعلم حول الوزن العروضي ونظام القافية:
            "{meter_rhyme_correction}"

            وهنا بعض الأمثلة المسترجعة من القصائد التي تتبع البحر {meter} والقافية {rhyme}:
            "{meter_rhyme_examples}"

            الرجاء إعادة كتابة القصيدة بحيث تتناسب مع الوزن والقافية الصحيحة.
            """
        }
    ]

    response = openai.ChatCompletion.create(
        model="gpt-4",  # Using GPT-4 for student model
        messages=messages,
        max_tokens=300,  # Adjust for the rewritten poem
        temperature=0.7
    )

    # Extract the poem rewritten by the student model
    rewritten_poem = response['choices'][0]['message']['content'].strip()
    return rewritten_poem

# Main function to run the process for meter and rhyme correction and rewriting
def main():
    # Example student poem, meter, and rhyme
    student_poem = """
    كأن الحزن بحرٌ يملأ روحي ** يغمرني حتى تذوب أحلامي في أعماقه
    والغيوم تغطي سمائي، تغيب الشمس ** يتركني في ظلام لا يرى صباحه
    """
import openai
from sentence_transformers import SentenceTransformer
import numpy as np

def search_poems_faiss(query, num_results=5):
    # Encode the query into an embedding
    query_embedding = model.encode([query], convert_to_tensor=False)

    # Search for top N closest embeddings using FAISS
    distances, indices = index.search(np.array(query_embedding), num_results)

    # Return the top N poems based on FAISS ranking
    return [poem_texts[i] for i in indices[0]]

# Step 3: Teacher model analyzes and corrects the poem's meter and rhyme scheme
def correct_poem_meter_and_rhyme(student_poem, meter, rhyme):
    messages = [
        {
            "role": "system",
            "content": f"""أنت خبير في العروض والشعر العربي. هدفك هو تحليل القصيدة التالية وتقديم التصحيحات اللازمة وفقًا للوزن والبحر الشعري ({meter}) ونظام القافية ({rhyme}). قدم الصيغة العروضية الصحيحة لهذا البحر، واقترح القافية الصحيحة التي تتناسب مع الأبيات.

البحر الطويل يتكون من التفعيلات التالية: فعولن مفاعيلن فعولن مفاعيلن.
التزم بهذه التفعيلات في كل شطر من القصيدة، وقم بتعديل الأبيات بحيث تتماشى مع هذه الصيغة العروضية.

بالنسبة للقافية ({rhyme})، تأكد من أن نهاية كل بيت تتبع هذا النظام واقترح قافية مناسبة إذا لم تكن موجودة.
            """
        },
        {
            "role": "user",
            "content": f"""
            هذه القصيدة التي كتبها الطالب:
            "{student_poem}"

            الرجاء تصحيح الوزن العروضي والقافية لهذه القصيدة وفقًا للبحر {meter} والقافية {rhyme}.
            """
        }
    ]

    response = openai.ChatCompletion.create(
        model="gpt-4",  # Using GPT-4 for teacher model
        messages=messages,
        max_tokens=300,  # Adjust for detailed feedback
        temperature=0.7
    )

    # Extract the feedback from the teacher model
    meter_rhyme_correction = response['choices'][0]['message']['content'].strip()
    return meter_rhyme_correction

# Student model rewrites the poem based on feedback from the teacher and examples from RAG
def rewrite_poem_with_meter_and_rhyme_feedback(student_poem, meter_rhyme_correction, meter, rhyme):
    # Retrieve top 5 poems with the correct meter and rhyme using FAISS
    query = f"Meter: {meter}, Rhyme: {rhyme}"
    retrieved_meter_rhyme_poems = search_poems_faiss(query, num_results=5)

    # Prepare the top 5 retrieved poems with the correct meter and rhyme
    meter_rhyme_examples = "\n\n".join(retrieved_meter_rhyme_poems)

    # Print the retrieved examples of poems with the correct meter and rhyme
    print(f"الأمثلة المسترجعة من FAISS حول البحر {meter} والقافية {rhyme}:\n{meter_rhyme_examples}\n")

    # Student model prompt with the original poem, feedback from the teacher, and meter and rhyme examples
    messages = [
        {
            "role": "system",
            "content": """ بناءً على التصحيح المقدم من المعلم حول الوزن العروضي ونظام القافية، هدفك هو إعادة كتابة القصيدة بحيث تتوافق مع الوزن المناسب والقافية الصحيحة. استخدم الاستعارات والصور الشعرية السابقة، وركز على كيفية دمجها مع الوزن والقافية بشكل سلس.

تذكر أن البحر الطويل يتكون من تفعيل "فعولن مفاعيلن فعولن مفاعيلن"، والقافية التي اخترتها هي "{rhyme}". تأكد من أن نهاية كل بيت تتبع هذا النظام بدقة. استعن بالأمثلة المسترجعة من القصائد لتوضيح كيفية تطبيق الوزن العروضي والقافية.
            """
        },
        {
            "role": "user",
            "content": f"""
            هذه هي القصيدة الأصلية التي كتبتها:
            "{student_poem}"

            وهنا التصحيحات التي قدمها المعلم حول الوزن العروضي ونظام القافية:
            "{meter_rhyme_correction}"

            وهنا بعض الأمثلة المسترجعة من القصائد التي تتبع البحر {meter} والقافية {rhyme}:
            "{meter_rhyme_examples}"

            الرجاء إعادة كتابة القصيدة بحيث تتناسب مع الوزن والقافية الصحيحة.
            """
        }
    ]

    response = openai.ChatCompletion.create(
        model="gpt-4",  # Using GPT-4 for student model
        messages=messages,
        max_tokens=300,  # Adjust for the rewritten poem
        temperature=0.7
    )

    # Extract the poem rewritten by the student model
    rewritten_poem = response['choices'][0]['message']['content'].strip()
    return rewritten_poem

# Main function to run the process for meter and rhyme correction and rewriting
def main():
    # Example student poem, meter, and rhyme
    student_poem = """
    كأن الحزن بحرٌ يملأ روحي ** يغمرني حتى تذوب أحلامي في أعماقه
    والغيوم تغطي سمائي، تغيب الشمس ** يتركني في ظلام لا يرى صباحه
    """
    meter = "الطويل"  # Example meter: "الطويل"
    rhyme = "د"  # Example rhyme

    # Step 3: Teacher model corrects the meter and rhyme and provides feedback
    meter_rhyme_correction = correct_poem_meter_and_rhyme(student_poem, meter, rhyme)
    print(f"تصحيح المعلم حول الوزن العروضي والقافية للبحر {meter} والقافية {rhyme}:\n{meter_rhyme_correction}\n")

    # Step 4: Student model rewrites the poem based on feedback and RAG examples
    rewritten_poem = rewrite_poem_with_meter_and_rhyme_feedback(student_poem, meter_rhyme_correction, meter, rhyme)
    print(f"القصيدة بعد التصحيح وإعادة الكتابة:\n{rewritten_poem}\n")

# Run the main process
if __name__ == "__main__":
    main()


    # Step 3: Teacher model corrects the meter and rhyme and provides feedback
    meter_rhyme_correction = correct_poem_meter_and_rhyme(student_poem, meter, rhyme)
    print(f"تصحيح المعلم حول الوزن العروضي والقافية للبحر {meter} والقافية {rhyme}:\n{meter_rhyme_correction}\n")

    # Step 4: Student model rewrites the poem based on feedback and RAG examples
    rewritten_poem = rewrite_poem_with_meter_and_rhyme_feedback(student_poem, meter_rhyme_correction, meter, rhyme)
    print(f"القصيدة بعد التصحيح وإعادة الكتابة:\n{rewritten_poem}\n")

# Run the main process
if __name__ == "__main__":
    main()

"""**d- teacher model provides words that rhyme with the context, and the student model adjusts the rhythm accordingly.**"""

import openai
from sentence_transformers import SentenceTransformer
import numpy as np

# Set your API key for OpenAI
openai.api_key = "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"

# Initialize the pre-trained model for embedding
model = SentenceTransformer('bert-base-nli-mean-tokens')

# FAISS-based poem retrieval function (assuming FAISS index and poem texts are pre-loaded)
def search_poems_faiss(query, num_results=5):
    # Encode the query into an embedding
    query_embedding = model.encode([query], convert_to_tensor=False)

    # Search for top N closest embeddings using FAISS
    distances, indices = index.search(np.array(query_embedding), num_results)

    # Return the top N poems based on FAISS ranking
    return [poem_texts[i] for i in indices[0]]

# Step 3: Teacher model analyzes, fixes rhythm, and suggests rhyme words
def fix_rhythm_and_suggest_rhyme(student_poem):
    messages = [
        {
            "role": "system",
            "content": """أنت خبير في العروض والشعر العربي. هدفك هو تصحيح الوزن والإيقاع للقصيدة التالية وتحديد حرف القافية المناسب لكل الأبيات. بعد اختيار حرف القافية، قدم بعض الكلمات التي تتماشى مع نهاية الأبيات وتتناسب مع معاني القصيدة.

الرجاء أيضًا تقديم اقتراحات لكيفية تحسين الإيقاع في الأبيات.
            """
        },
        {
            "role": "user",
            "content": f"""
            هذه القصيدة التي كتبها الطالب:
            "{student_poem}"

            الرجاء تصحيح الوزن وتحديد حرف القافية المناسب، وتقديم أمثلة لكلمات تنتهي بنفس الحرف ويمكن استخدامها لتتماشى مع المعاني.
            """
        }
    ]

    response = openai.ChatCompletion.create(
        model="gpt-4",  # Using GPT-4 for teacher model
        messages=messages,
        max_tokens=400,  # Adjust for detailed feedback
        temperature=0.7
    )

    # Extract the feedback and rhyme suggestions from the teacher model
    rhythm_correction = response['choices'][0]['message']['content'].strip()
    return rhythm_correction

# Step 4: Student model rewrites the poem based on teacher feedback and retrieves poems with the same rhyme from RAG
def rewrite_poem_with_rhyme_feedback(student_poem, rhyme_correction, rhyme_letter):
    # Retrieve top 5 poems with the same rhyme letter using FAISS
    query = f"Rhyme: {rhyme_letter}"
    retrieved_rhyme_poems = search_poems_faiss(query, num_results=5)

    # Prepare the top 5 retrieved poems with the same rhyme letter
    rhyme_examples = "\n\n".join(retrieved_rhyme_poems)

    # Print the retrieved examples of poems with the same rhyme
    print(f"الأمثلة المسترجعة من FAISS حول القافية {rhyme_letter}:\n{rhyme_examples}\n")

    # Student model prompt with the original poem, feedback from the teacher, and rhyme examples
    messages = [
        {
            "role": "system",
            "content": """بناءً على التصحيح المقدم من المعلم حول الإيقاع والقافية، هدفك هو إعادة كتابة القصيدة بحيث تتوافق مع الوزن والقافية المناسبين. استخدم الاستعارات والصور الشعرية السابقة، وركز على كيفية دمجها مع الكلمات التي تتناسب مع القافية.

استخدم الأمثلة المسترجعة من القصائد التي تنتهي بنفس الحرف.
            """
        },
        {
            "role": "user",
            "content": f"""
            هذه هي القصيدة الأصلية التي كتبتها:
            "{student_poem}"

            وهنا التصحيحات التي قدمها المعلم حول الوزن والقافية:
            "{rhyme_correction}"

            وهنا بعض الأمثلة المسترجعة من القصائد التي تتبع القافية {rhyme_letter}:
            "{rhyme_examples}"

            الرجاء إعادة كتابة القصيدة بحيث تتناسب مع الوزن والقافية الصحيحة.
            """
        }
    ]

    response = openai.ChatCompletion.create(
        model="gpt-4",  # Using GPT-4 for student model
        messages=messages,
        max_tokens=400,  # Adjust for the rewritten poem
        temperature=0.7
    )

    # Extract the poem rewritten by the student model
    rewritten_poem = response['choices'][0]['message']['content'].strip()
    return rewritten_poem

# Main function to run the process for rhythm correction and rewriting based on rhyme
def main():
    # Example student poem
    student_poem = """
    كأن الحزن بحرٌ يملأ الروحي ** ويغمرني حتى تذوب أحلامي
    والغيم يغشى السماء والشمس تغيب ** يتركني في ظلام لا يرى الصباح
    """

    # Step 3: Teacher model fixes rhythm and suggests rhyme words
    rhyme_correction = fix_rhythm_and_suggest_rhyme(student_poem)
    print(f"تصحيح المعلم حول الوزن والقافية:\n{rhyme_correction}\n")

    # Choose a rhyme letter (e.g., 'ح' for القافية "الصباح")
    rhyme_letter = "ح"

    # Step 4: Student model rewrites the poem based on feedback and rhyme examples from RAG
    rewritten_poem = rewrite_poem_with_rhyme_feedback(student_poem, rhyme_correction, rhyme_letter)
    print(f"القصيدة بعد التصحيح وإعادة الكتابة:\n{rewritten_poem}\n")

# Run the main process
if __name__ == "__main__":
    main()

"""**e-Final refinement from teacher**



"""

import openai

# Set your API key for OpenAI
openai.api_key = "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"

# Function for teacher to review the final poem, fix errors, and select the best lines
def teacher_final_review(rewritten_poem):
    messages = [
        {
            "role": "system",
            "content": """أنت خبير في الأدب والشعر العربي. هدفك هو مراجعة القصيدة التالية التي كتبها الطالب بعد التصحيح. قم بتصحيح أي أخطاء في الوزن أو القافية إذا لزم الأمر، واختر أفضل الأبيات التي تظن أنها تعكس الشعر بشكل جيد.

الرجاء تقديم النسخة النهائية للقصيدة بعد التصحيح والاختيار.
            """
        },
        {
            "role": "user",
            "content": f"""
            هذه القصيدة المعدلة التي كتبها الطالب بعد التصحيح:
            "{rewritten_poem}"

            الرجاء مراجعتها وتقديم النسخة النهائية بعد التصحيح واختيار الأبيات الأفضل.
            """
        }
    ]

    response = openai.ChatCompletion.create(
        model="gpt-4",  # Using GPT-4 for teacher model
        messages=messages,
        max_tokens=400,  # Adjust for detailed feedback
        temperature=0.7
    )

    # Extract the final reviewed poem from the teacher model
    final_output = response['choices'][0]['message']['content'].strip()
    return final_output

# Example usage of Step 5
def main():
    # Example rewritten poem from student
    rewritten_poem = """

   الحزن بحرٌ غمر الروح والقلم ** غرقت الأحلام فيه وأنا أرقب
والغيم يغشى السماء والشمس غابت ** تركني في ظلمة، ليس لها صبح

من حُبّه لي قد غدا القلب نسيم ** يهتز له ويشتاق، ولكنه يكابد
وبالألم والحزن، أصبح العمر ضيم ** مرقد الأمل خالٍ، والفؤاد يعاني

وكأن الأمل غصنٌ، قد تكسر بالهم ** والحياة موج متلاطم، لا يهدأ
وكأن الحزن قد ألقى على الروح ضبابه ** يحجب النور عنها، ويجعل البصيرة عمياء.

    """

    # Step 5: Teacher model reviews the final poem and provides the final output
    final_poem = teacher_final_review(rewritten_poem)
    print(f"القصيدة النهائية بعد مراجعة المعلم:\n{final_poem}\n")

# Run the main process for step 5
if __name__ == "__main__":
    main()

"""شعفخ"""

from sentence_transformers import SentenceTransformer
import numpy as np

# Initialize the pre-trained model for embedding (SentenceTransformer)
embedding_model = SentenceTransformer('bert-base-nli-mean-tokens')

def search_poems_faiss(query, num_results=5):
    # Encode the query into an embedding using the SentenceTransformer model
    query_embedding = embedding_model.encode([query], convert_to_tensor=False)

    # Assuming 'index' is a preloaded FAISS index and 'poem_texts' is a list of poems
    distances, indices = index.search(np.array(query_embedding), num_results)

    # Return the top N poems based on FAISS ranking
    return [poem_texts[i] for i in indices[0]]

from rank_bm25 import BM25Okapi

def retrieve_poems_bm25(poet, meter):
    print(f"Retrieving top poems for poet '{poet}' and meter '{meter}' using BM25...")

    # Create a query combining poet and meter
    query = f"{poet} {meter}"
    tokenized_query = query.split(" ")

    # Get BM25 scores
    bm25_scores = bm25.get_scores(tokenized_query)

    # Get top 3 poems by this poet and meter
    top_n = 3
    top_bm25_results = df.loc[bm25_scores.argsort()[::-1]].head(top_n)

    top_poems = top_bm25_results['البيت'].tolist()

    print(f"Retrieved BM25 poems: {top_poems}")
    return top_poems

from sentence_transformers import SentenceTransformer

# Initialize the Sentence-BERT model (ensure it is properly initialized here)
model = SentenceTransformer('sentence-transformers/bert-base-nli-mean-tokens')

# Check if the model is initialized correctly
print("SentenceTransformer model initialized successfully!")

def retrieve_poems_faiss(query, num_results=3):
    print(f"Retrieving top poems based on meaning and metaphors using FAISS...")

    # Encode the query
    query_embedding = model.encode([query], convert_to_tensor=False)

    # Search for top N closest embeddings using FAISS
    distances, indices = index.search(np.array(query_embedding), num_results)

    # Return the top N poems
    top_poems = [poem_texts[i] for i in indices[0]]

    print(f"Retrieved FAISS poems: {top_poems}")
    return top_poems

def teacher_provide_metaphor_and_emotion_context(emotion, user_context):
    print(f"Teacher is providing metaphor and context for emotion: {emotion}")

    messages = [
        {
            "role": "system",
            "content": "أنت خبير في الأدب والشعر العربي. قدم استعارات وصورًا شعرية توضح هذا الشعور."
        },
        {
            "role": "user",
            "content": f"قدم لي استعارات حول شعور {emotion}. {user_context}"
        }
    ]
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=messages,
        max_tokens=300,
        temperature=0.7
    )

    # Extract metaphor context and retrieve similar poems
    emotion_context = response['choices'][0]['message']['content'].strip()
    print(f"Metaphor context provided by teacher: {emotion_context}")

    faiss_results = retrieve_poems_faiss(emotion, 3)

    return emotion_context, faiss_results

def student_generate_first_poem(emotion_context, retrieved_poems, watson_model):
    print(f"Student is generating the first poem based on provided metaphor context and retrieved poems...")

    prompt = f"""<s> [INST] بناءً على السياق التالي الذي قدمه المعلم:
    "{emotion_context}"

    الأمثلة المسترجعة من القصائد:
    "{retrieved_poems}"

    اكتب قصيدة تعكس هذا الشعور. [/INST]"""

    response = watson_model.generate_text(prompt=prompt, guardrails=False)
    student_poem = response.strip()  # Assuming plain text response

    print(f"Student-generated poem: {student_poem}")
    return student_poem

def teacher_fix_meter_and_weight(student_poem, meter):
    print(f"Teacher is fixing the meter and weight for meter: {meter}")

    messages = [
        {
            "role": "system",
            "content": f"أنت خبير في العروض والشعر العربي. صحح الوزن العروضي لهذا البحر {meter}."
        },
        {
            "role": "user",
            "content": f"هذه القصيدة: {student_poem}"
        }
    ]

    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=messages,
        max_tokens=300,
        temperature=0.7
    )

    # Retrieve similar poems with the same meter using BM25
    meter_correction = response['choices'][0]['message']['content'].strip()
    print(f"Teacher's meter correction: {meter_correction}")

    bm25_meter_results = retrieve_poems_bm25(poet_dropdown.value, meter)

    return meter_correction, bm25_meter_results

def student_fix_poem_meter(student_poem, meter_correction, meter_examples, watson_model):
    print("Student is fixing the poem based on meter corrections and examples...")

    prompt = f"""<s> [INST] هذه تصحيحات المعلم للوزن العروضي:
    "{meter_correction}"

    الأمثلة المسترجعة للبحر:
    "{meter_examples}"

    الرجاء إعادة كتابة القصيدة وفقًا للتصحيحات. [/INST]"""

    response = watson_model.generate_text(prompt=prompt, guardrails=False)
    revised_poem = response.strip()

    print(f"Student-revised poem based on meter: {revised_poem}")
    return revised_poem

def teacher_fix_rhyme_and_finalize(revised_poem, rhyme):
    print(f"Teacher is fixing rhyme and finalizing the poem for rhyme: {rhyme}")

    messages = [
        {
            "role": "system",
            "content": f"صحح القافية لهذه القصيدة وتأكد من استكمال جميع العناصر."
        },
        {
            "role": "user",
            "content": f"هذه القصيدة بعد تصحيح الوزن: {revised_poem}"
        }
    ]

    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=messages,
        max_tokens=300,
        temperature=0.7
    )

    final_poem = response['choices'][0]['message']['content'].strip()
    print(f"Finalized poem after rhyme correction: {final_poem}")

    return final_poem

# Function to initialize the Watson model (replace the credentials and parameters with actual values)
def initialize_watson_model():
    credentials = {
        "url": "https://eu-de.ml.cloud.ibm.com",  # Replace with the actual URL
        "apikey": "bkIJnxA7mDVQPkbqGnjbeWQZnNjqXIoM9nmP5f7tQ_jU"  # Replace with your actual API key
    }

    model_id = "sdaia/allam-1-13b-instruct"  # Replace with the actual model ID
    parameters = {
        "decoding_method": "greedy",
        "max_new_tokens": 500,
        "repetition_penalty": 1.0
    }

    project_id = "65870abf-b0eb-4dce-9b63-eeed50e3a3d0"  # Replace with your actual project ID
    space_id = os.getenv("SPACE_ID")  # Replace with your actual space ID

    # Initialize Watson model
    watson_model = Model(
        model_id=model_id,
        params=parameters,
        credentials=credentials,
        project_id=project_id,
        space_id=space_id
    )

    print("Watson model initialized successfully!")
    return watson_model

def main():
    print("Main function started.")

    # Step 0: Initialize Watson model
    watson_model = initialize_watson_model()

    # Get user input
    user_input = get_user_input_debug()

    if not user_input:
        print("No user input received.")
        return

    print(f"Processing with user input: {user_input}")

    # Step 1: Teacher provides metaphor and retrieves poems based on emotion and context
    emotion_context, faiss_results = teacher_provide_metaphor_and_emotion_context(user_input["emotion"], user_input["context"])

    print(f"Metaphor context: {emotion_context}")
    print(f"FAISS results: {faiss_results}")

    # Step 2: Student generates the first poem
    student_poem = student_generate_first_poem(emotion_context, faiss_results, watson_model)
    print(f"Student-generated poem: {student_poem}")

    # Step 3: Teacher fixes meter and weight
    meter_correction, meter_examples = teacher_fix_meter_and_weight(student_poem, user_input["meter"])
    print(f"Meter correction: {meter_correction}")
    print(f"Meter examples: {meter_examples}")

    # Step 4: Student revises poem based on meter feedback
    revised_poem = student_fix_poem_meter(student_poem, meter_correction, meter_examples, watson_model)
    print(f"Revised poem: {revised_poem}")

    # Step 5: Teacher fixes rhyme and finalizes the poem
    final_poem = teacher_fix_rhyme_and_finalize(revised_poem, "د")  # Example rhyme "د"

    print(f"Final Poem: \n{final_poem}")

# Start the process when submit button is clicked
submit_button.on_click(lambda _: main())

# Function to initialize the Watson model
from ibm_watsonx_ai.foundation_models import Model

def initialize_watson_model():
    credentials = {
        "url": "https://eu-de.ml.cloud.ibm.com",  # Replace with your actual URL
        "apikey": "bkIJnxA7mDVQPkbqGnjbeWQZnNjqXIoM9nmP5f7tQ_jU"  # Replace with your actual API key
    }

    model_id = "sdaia/allam-1-13b-instruct"  # Replace with the correct model ID
    parameters = {
        "decoding_method": "greedy",
        "max_new_tokens": 500,
        "repetition_penalty": 1.0
    }

    project_id = "65870abf-b0eb-4dce-9b63-eeed50e3a3d0"  # Replace with your project ID
    space_id = os.getenv("SPACE_ID")  # Replace with your space ID

    # Initialize Watson model
    watson_model = Model(
        model_id=model_id,
        params=parameters,
        credentials=credentials,
        project_id=project_id,
        space_id=space_id
    )

    print("Watson model initialized successfully!")
    return watson_model

# Main workflow with Watson model passed in
def main():
    print("Main function started.")

    # Step 0: Initialize Watson model
    watson_model = initialize_watson_model()

    # Get user input
    user_input = get_user_input_debug()

    if not user_input:
        print("No user input received.")
        return

    print(f"Processing with user input: {user_input}")

    # Step 1: Teacher provides metaphor and retrieves poems based on emotion and context
    emotion_context, faiss_results = teacher_provide_metaphor_and_emotion_context(user_input["emotion"], user_input["context"])

    print(f"Metaphor context: {emotion_context}")
    print(f"FAISS results: {faiss_results}")

    # Step 2: Student generates the first poem (Pass watson_model here)
    student_poem = student_generate_first_poem(emotion_context, faiss_results, watson_model)
    print(f"Student-generated poem: {student_poem}")

    # Step 3: Teacher fixes meter and weight
    meter_correction, meter_examples = teacher_fix_meter_and_weight(student_poem, user_input["meter"])
    print(f"Meter correction: {meter_correction}")
    print(f"Meter examples: {meter_examples}")

    # Step 4: Student revises poem based on meter feedback (Pass watson_model here)
    revised_poem = student_fix_poem_meter(student_poem, meter_correction, meter_examples, watson_model)
    print(f"Revised poem: {revised_poem}")

    # Step 5: Teacher fixes rhyme and finalizes the poem
    final_poem = teacher_fix_rhyme_and_finalize(revised_poem, "د")  # Example rhyme "د"

    print(f"Final Poem: \n{final_poem}")

# Start the process when submit button is clicked
submit_button.on_click(lambda _: main())

import os
import getpass
from ibm_watsonx_ai.foundation_models import Model

# Function to get credentials securely
def get_credentials():
    return {
        "url": "https://eu-de.ml.cloud.ibm.com",  # Verify that this URL is correct for your service region
        "apikey": getpass.getpass("Enter your API key: ")  # Securely input API key
    }

# Fetch credentials
credentials = get_credentials()

# Define the model ID, ensuring it is correct and properly deployed on IBM Watsonx AI
model_id = "sdaia/allam-1-13b-instruct"  # Make sure this model ID matches the deployed model

# Define the parameters for model inference
parameters = {
    "decoding_method": "greedy",
    "max_new_tokens": 900,
    "repetition_penalty": 1.0
}

# Set up project and space IDs; ensure these IDs are correctly retrieved or set
project_id = "65870abf-b0eb-4dce-9b63-eeed50e3a3d0"  # Replace with your actual project ID
space_id = os.getenv("SPACE_ID")  # Make sure SPACE_ID is set in your environment variables

# Initialize the model using the IBM Watsonx AI SDK
try:
    watson_model = Model(
        model_id=model_id,
        params=parameters,
        credentials=credentials,
        project_id=project_id,
        space_id=space_id
    )
    print("Model initialized successfully!")
except Exception as e:
    print(f"Error initializing the model: {e}")

import ipywidgets as widgets
from IPython.display import display

# Dropdown lists for user input
poet_names = [
    'الطرماح بن حكيم الطائي', 'الراعي النُمَيري', 'عروة بن أذينة', 'سبيعة بنت الأحب',
    'أبو دؤاد الإيادي', 'عَبدُ مالِك بن النُّعْمان'
]

meters = [
    'الكامل', 'الطويل', 'المتقارب', 'البسيط', 'الوافر', 'المديد', 'الرمل',
    'السريع', 'الرجز', 'الخفيف', 'المنسرح', 'المجتث', 'موشح', 'الهزج',
    'شعر التفعيلة', 'المتدارك', 'عامي', 'شعر حر', 'السلسلة', 'المواليا', 'الدوبيت'
]

emotions = ['Pride', 'Praise', 'Sadness', 'Satire', 'Love']

# Creating dropdowns
poet_dropdown = widgets.Dropdown(options=poet_names, description='Poet:')
meter_dropdown = widgets.Dropdown(options=meters, description='Meter:')
emotion_dropdown = widgets.Dropdown(options=emotions, description='Emotion:')
context_text = widgets.Text(description='Context:')

# Display the widgets
display(poet_dropdown, meter_dropdown, emotion_dropdown, context_text)

# Function to collect user input
def get_user_input():
    return {
        "poet_name": poet_dropdown.value,
        "meter": meter_dropdown.value,
        "emotion": emotion_dropdown.value,
        "context": context_text.value
    }

submit_button = widgets.Button(description="Submit")
display(submit_button)

# Add print to confirm user input
def get_user_input_debug():
    user_input = get_user_input()
    print(f"User Input: {user_input}")  # Ensure the input is captured and printed
    return user_input

# Ensure your models are initialized correctly
def main():
    print("Main function started.")  # Debugging start point

    user_input = get_user_input_debug()

    if not user_input:
        print("No user input received.")
        return

    print(f"Processing with user input: {user_input}")

    # Step 1: Teacher provides metaphor and retrieves poems based on emotion and context
    emotion_context, faiss_results = teacher_provide_metaphor_and_emotion_context(user_input["emotion"], user_input["context"])

    print(f"Metaphor context: {emotion_context}")
    print(f"FAISS results: {faiss_results}")

    # Step 2: Student generates the first poem
    student_poem = student_generate_first_poem(emotion_context, faiss_results, watson_model)
    print(f"Student-generated poem: {student_poem}")

    # Step 3: Teacher fixes meter and weight
    meter_correction, meter_examples = teacher_fix_meter_and_weight(student_poem, user_input["meter"])
    print(f"Meter correction: {meter_correction}")
    print(f"Meter examples: {meter_examples}")

    # Step 4: Student revises poem based on meter feedback
    revised_poem = student_fix_poem_meter(student_poem, meter_correction, meter_examples, watson_model)
    print(f"Revised poem: {revised_poem}")

    # Step 5: Teacher fixes rhyme and finalizes the poem
    final_poem = teacher_fix_rhyme_and_finalize(revised_poem, "د")  # Example rhyme "د"

    print(f"Final Poem: \n{final_poem}")

# Start the process when submit button is clicked
submit_button.on_click(lambda _: main())

import streamlit as st
import pandas as pd
from sentence_transformers import SentenceTransformer
import faiss
import numpy as np
from rank_bm25 import BM25Okapi
from ibm_watsonx_ai.foundation_models import Model
import os
import getpass

# Streamlit title
st.title('Arabic Poetry Generator')

# Load dataset from uploaded file
uploaded_file = st.file_uploader("Upload your poetry dataset (CSV or JSON)")
if uploaded_file:
    df = pd.read_csv(uploaded_file)  # Assuming it's a CSV file
    st.write("Data preview:")
    st.write(df.head())
else:
    st.warning("Please upload a poetry dataset to proceed.")
    st.stop()

# Initialize FAISS and BM25 models
st.text("Initializing FAISS and BM25 models...")

# Initialize Sentence-BERT model for FAISS
model = SentenceTransformer('sentence-transformers/bert-base-nli-mean-tokens')
poem_texts = [poem for poem in df['البيت']]
poem_embeddings = model.encode(poem_texts, convert_to_tensor=False)
poem_embeddings = np.array(poem_embeddings)

# Initialize FAISS index for fast retrieval
dimension = poem_embeddings.shape[1]
index = faiss.IndexFlatL2(dimension)
index.add(poem_embeddings)

# BM25 Initialization
df['combined_text'] = df[['الشاعر', 'البحر']].apply(lambda row: ' '.join(row.values.astype(str)), axis=1)
tokenized_corpus = [doc.split(" ") for doc in df['combined_text'].values]
bm25 = BM25Okapi(tokenized_corpus)

# IBM Watson Model Credentials
st.text("Initializing IBM Watson model...")
def get_credentials():
    return {
        "url": "https://eu-de.ml.cloud.ibm.com",
        "apikey": getpass.getpass("Enter your API key: ")
    }

credentials = get_credentials()

model_id = "sdaia/allam-1-13b-instruct"
parameters = {
    "decoding_method": "greedy",
    "max_new_tokens": 900,
    "repetition_penalty": 1.0
}
project_id = "65870abf-b0eb-4dce-9b63-eeed50e3a3d0"
space_id = os.getenv("SPACE_ID")

try:
    watson_model = Model(
        model_id=model_id,
        params=parameters,
        credentials=credentials,
        project_id=project_id,
        space_id=space_id
    )
    st.success("Watson model initialized successfully!")
except Exception as e:
    st.error(f"Error initializing the model: {e}")
    st.stop()

# Collect user inputs for poet, meter, and emotion
poet_name = st.selectbox("Select the Poet", df['الشاعر'].unique())
meter = st.selectbox("Select the Meter", df['البحر'].unique())
emotion = st.selectbox("Select the Emotion", ["Pride", "Love", "Sadness", "Satire", "Praise"])
context = st.text_input("Enter Context", "Example: Afkhar bi akhi (I am proud of my brother)")

# Trigger poem generation when the user clicks the button
if st.button("Generate Poem"):

    # Step 1: Retrieve Metaphor and Context using Watson model
    st.text("Retrieving metaphors and context...")

    def teacher_provide_metaphor_and_emotion_context(emotion, user_context):
        prompt = f"Provide metaphors related to the feeling of {emotion}. {user_context}"
        response = watson_model.generate_text(prompt=prompt, guardrails=False)
        return response.strip()

    emotion_context = teacher_provide_metaphor_and_emotion_context(emotion, context)

    # Step 2: Retrieve poems using BM25 for poet and meter
    st.text("Retrieving poems using BM25...")

    def retrieve_poems_bm25(poet, meter, num_results=3):
        query = f"{poet} {meter}"
        tokenized_query = query.split(" ")
        bm25_scores = bm25.get_scores(tokenized_query)
        top_bm25_results = df.loc[bm25_scores.argsort()[::-1]].head(num_results)
        return top_bm25_results['البيت'].tolist()

    bm25_poems = retrieve_poems_bm25(poet_name, meter)

    # Step 3: Retrieve poems using FAISS based on emotion
    st.text("Retrieving poems using FAISS...")

    def retrieve_poems_faiss(query, num_results=3):
        query_embedding = model.encode([query], convert_to_tensor=False)
        distances, indices = index.search(np.array(query_embedding), num_results)
        return [poem_texts[i] for i in indices[0]]

    faiss_poems = retrieve_poems_faiss(emotion)

    # Step 4: Generate the first draft of the poem using Watson model
    st.text("Generating the poem...")

    def student_generate_first_poem(emotion_context, retrieved_poems):
        prompt = f"Based on the following context: {emotion_context}, and examples: {retrieved_poems}, generate a poem."
        response = watson_model.generate_text(prompt=prompt, guardrails=False)
        return response.strip()

    generated_poem = student_generate_first_poem(emotion_context, bm25_poems + faiss_poems)
    st.text("Generated Poem:")
    st.write(generated_poem)

    # Step 5: Meter correction using Watson model
    st.text("Correcting meter and weight...")

    def teacher_fix_meter_and_weight(student_poem, meter):
        prompt = f"Fix the meter and weight of this poem: {student_poem} to match the {meter} meter."
        response = watson_model.generate_text(prompt=prompt, guardrails=False)
        return response.strip()

    corrected_poem = teacher_fix_meter_and_weight(generated_poem, meter)
    st.text("Meter Corrected Poem:")
    st.write(corrected_poem)

    # Step 6: Final rhyme adjustment
    st.text("Finalizing rhyme...")

    def teacher_fix_rhyme_and_finalize(revised_poem, rhyme="د"):
        prompt = f"Adjust the rhyme of this poem: {revised_poem} to match the {rhyme} rhyme."
        response = watson_model.generate_text(prompt=prompt, guardrails=False)
        return response.strip()

    final_poem = teacher_fix_rhyme_and_finalize(corrected_poem)
    st.text("Final Poem:")
    st.write(final_poem)

